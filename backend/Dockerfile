# =============================================================================
# DOCKERFILE IDEAL PARA DJANGO + CAPROVER
# =============================================================================
# Este Dockerfile segue as melhores prÃ¡ticas para deploy no CapRover:
# - VariÃ¡veis de ambiente sÃ£o lidas apenas em RUNTIME (nÃ£o no build)
# - collectstatic e migrations sÃ£o executados pelo script de entrada
# - Build leve e rÃ¡pido (usa cache eficientemente)
# =============================================================================

FROM python:3.12-slim

# -----------------------------------------------------------------------------
# VariÃ¡veis de ambiente bÃ¡sicas (nÃ£o dependem de config externa)
# -----------------------------------------------------------------------------
ENV PYTHONUNBUFFERED=1 \
    PYTHONDONTWRITEBYTECODE=1 \
    # PIP configs para instalaÃ§Ã£o mais rÃ¡pida
    PIP_NO_CACHE_DIR=1 \
    PIP_DISABLE_PIP_VERSION_CHECK=1

# -----------------------------------------------------------------------------
# Instalar dependÃªncias do sistema
# -----------------------------------------------------------------------------
RUN apt-get update && apt-get install -y --no-install-recommends \
    # Para compilar pacotes Python com extensÃµes C
    gcc \
    # Cliente PostgreSQL (psycopg2)
    libpq-dev \
    postgresql-client \
    # Supervisor para gerenciar mÃºltiplos processos (Gunicorn + Celery)
    supervisor \
    # Limpar cache do apt para reduzir tamanho da imagem
    && apt-get clean \
    && rm -rf /var/lib/apt/lists/*

# -----------------------------------------------------------------------------
# Criar diretÃ³rio de trabalho
# -----------------------------------------------------------------------------
WORKDIR /app

# -----------------------------------------------------------------------------
# Instalar dependÃªncias Python (antes de copiar cÃ³digo para usar cache)
# -----------------------------------------------------------------------------
COPY requirements.txt .
RUN pip install --upgrade pip && \
    pip install -r requirements.txt && \
    pip install gunicorn

# -----------------------------------------------------------------------------
# Copiar cÃ³digo da aplicaÃ§Ã£o
# -----------------------------------------------------------------------------
COPY . .

# -----------------------------------------------------------------------------
# NÃƒO executar collectstatic aqui!
# As variÃ¡veis de ambiente (ALLOWED_HOSTS, DATABASE_URL, etc.) sÃ³ estÃ£o
# disponÃ­veis em RUNTIME, nÃ£o durante o build.
# O collectstatic serÃ¡ executado pelo entrypoint.sh
# -----------------------------------------------------------------------------

# -----------------------------------------------------------------------------
# Expor porta (CapRover usa porta 80 por padrÃ£o)
# -----------------------------------------------------------------------------
EXPOSE 80

# -----------------------------------------------------------------------------
# Criar script de entrada (entrypoint)
# Este script Ã© executado em RUNTIME quando as variÃ¡veis de ambiente estÃ£o disponÃ­veis
# -----------------------------------------------------------------------------
RUN echo '#!/bin/bash\n\
set -e\n\
\n\
echo "ðŸš€ Iniciando aplicaÃ§Ã£o Django..."\n\
echo "ðŸ“ Ambiente: ${ENVIRONMENT:-production}"\n\
\n\
# Coletar arquivos estÃ¡ticos\n\
echo "ðŸ“¦ Coletando arquivos estÃ¡ticos..."\n\
python manage.py collectstatic --noinput\n\
echo "âœ… Arquivos estÃ¡ticos coletados"\n\
\n\
# Aplicar migrations (com tratamento de erro de histÃ³rico inconsistente)\n\
echo "ðŸ“¦ Aplicando migrations..."\n\
set +e  # Desabilitar exit on error temporariamente\n\
MIGRATE_OUTPUT=$(python manage.py migrate --noinput 2>&1)\n\
MIGRATE_EXIT=$?\n\
set -e  # Reabilitar exit on error\n\
\n\
if [ $MIGRATE_EXIT -ne 0 ]; then\n\
    # Se houver erro de histÃ³rico inconsistente, corrigir automaticamente\n\
    if echo "$MIGRATE_OUTPUT" | grep -q "InconsistentMigrationHistory"; then\n\
        echo "âš ï¸  HistÃ³rico de migrations inconsistente detectado. Corrigindo..."\n\
        set +e  # Desabilitar exit on error durante correÃ§Ã£o\n\
        # Marcar migrations do bau_mental como aplicadas (fake)\n\
        python manage.py migrate bau_mental 0001_initial --fake 2>/dev/null || true\n\
        python manage.py migrate bau_mental 0002_alter_box_id_alter_note_id --fake 2>/dev/null || true\n\
        python manage.py migrate bau_mental 0003_alter_note_audio_file --fake 2>/dev/null || true\n\
        python manage.py migrate bau_mental 0004_alter_note_audio_file --fake 2>/dev/null || true\n\
        python manage.py migrate bau_mental 0005_add_fulltext_search --fake 2>/dev/null || true\n\
        python manage.py migrate bau_mental 0006_add_forwarded_source_type --fake 2>/dev/null || true\n\
        python manage.py migrate bau_mental 0007_add_note_tracking --fake 2>/dev/null || true\n\
        python manage.py migrate bau_mental 0008_add_box_sharing --fake 2>/dev/null || true\n\
        python manage.py migrate bau_mental 0009_remove_note_note_transcript_gin_idx_and_more --fake 2>/dev/null || true\n\
        set -e  # Reabilitar exit on error\n\
        echo "âœ… HistÃ³rico corrigido. Aplicando migrations restantes..."\n\
        python manage.py migrate --noinput\n\
    else\n\
        echo "âŒ Erro ao aplicar migrations:"\n\
        echo "$MIGRATE_OUTPUT"\n\
        exit 1\n\
    fi\n\
fi\n\
echo "âœ… Migrations aplicadas"\n\
\n\
# Verificar modo de execuÃ§Ã£o do Celery\n\
CELERY_MODE=${CELERY_MODE:-same}\n\
\n\
if [ "$CELERY_MODE" = "separate" ]; then\n\
    # Modo separado: apenas Gunicorn (quando Celery roda em container separado)\n\
    echo "ðŸš€ Modo separado: Iniciando apenas Gunicorn..."\n\
    exec gunicorn config.wsgi:application \\\n\
        --bind 0.0.0.0:80 \\\n\
        --workers ${GUNICORN_WORKERS:-3} \\\n\
        --timeout ${GUNICORN_TIMEOUT:-120} \\\n\
        --access-logfile - \\\n\
        --error-logfile -\n\
else\n\
    # Modo mesmo container: Supervisor gerencia Gunicorn + Celery\n\
    echo "ðŸš€ Modo mesmo container: Iniciando Gunicorn + Celery..."\n\
    exec /usr/bin/supervisord -c /etc/supervisor/conf.d/supervisord.conf\n\
fi' > /app/entrypoint.sh && chmod +x /app/entrypoint.sh

# -----------------------------------------------------------------------------
# ConfiguraÃ§Ã£o do Supervisor (Gunicorn + Celery no mesmo container)
# -----------------------------------------------------------------------------
RUN mkdir -p /etc/supervisor/conf.d && \
    echo '[supervisord]\n\
nodaemon=true\n\
\n\
[program:gunicorn]\n\
command=gunicorn config.wsgi:application --bind 0.0.0.0:80 --workers 3 --timeout 120 --access-logfile - --error-logfile -\n\
directory=/app\n\
autostart=true\n\
autorestart=true\n\
stderr_logfile=/dev/stderr\n\
stderr_logfile_maxbytes=0\n\
stdout_logfile=/dev/stdout\n\
stdout_logfile_maxbytes=0\n\
\n\
[program:celery]\n\
command=celery -A config worker -l info\n\
directory=/app\n\
autostart=true\n\
autorestart=true\n\
stderr_logfile=/dev/stderr\n\
stderr_logfile_maxbytes=0\n\
stdout_logfile=/dev/stdout\n\
stdout_logfile_maxbytes=0' > /etc/supervisor/conf.d/supervisord.conf

# -----------------------------------------------------------------------------
# Comando de entrada
# -----------------------------------------------------------------------------
CMD ["/app/entrypoint.sh"]
